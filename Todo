// CHeck if a client with same private key exists before accepting connection.


// all error printing will be done at heighest level only

// fix n chuks per file max + cleanup

code cleanup + error handling + proper communication.
browser download fix. Index db. 

only then we will move to webrtc

after that we may move to reallly Oloo fast mode


   // doing rn
   3 main things
   1. pause/resume handle. ❌ we will just delete that chunk. (on download it can happen, but not in upload, bcz civetweb dont support it. moderen browsers does though). 
   3. chunk management. increase or decrease parallelism. chunk size same. (use comparision with provided table to find if slow or fast).
   2. (later)multiple users downloading so should we optomize that ?


// ====================

   Ok so 
Current approach is good. But when client asks. It will also tell chunk size it needs to be. This just left with , 2 clients asking for same file. So when someone else asks same file being downloaded, it will tell ( when tell upload it ready) that these chunks are available, and they are locked for you. Download them first. ) client B will download them, then ask for new.

  or 

chunked size are good. we just change parallellism. only hit will be when pausing,

//  ===============
real todo

1. client send a public name when connecting.
2. Check if client already exist with this private ID. 
(so reconnet ? i think just reject if req is to connect. use reconnet for reconnect)
3. 


// IMP THINKING
 FOR KEEPING TRACK OF CHUNKS. AS CHUNK SIZE IS VAR. 
const chunks = new Map([
    [0, {size: 5MB, data: blob1, status: 'complete'}],
    [5242880, {size: 3MB, data: blob2, status: 'complete'}],
    [8388608, {size: 7MB, data: null, status: 'downloading'}]
]);

OR USE BINARY SEARCH TREE ? I DONT THINK MORE EFFICIENT, BCZ DOWNLOAD WILL BE SEQUENTIAL IN 99% CASES.

+ BUT WHAT ABOUT PARTY MODE
FIX SIZE THERE ? GIVE AVAILABLE CHUNKS + SIZE TO CLIENT WHEN IT ASK A FILE, OR BETTER, SAY REQUEST_AVAILABLE_CHUNKS(FILE), THEN 
RETURN A LIST OF CHUNKS AVAILABLE + LOCK IT TO HIM FOR IT.
THEN LATER CAN AGAIN DO REQUEST_AVAILABLE_CHUNKS(FILE) CHECK IF 
CHUNK DOWNLOADED. IF NOT THEN REQUEST HIS OWN.
TOP TIER OPTOMIZATION IT WILL BE. 
BUT EACH MAY HAVE ITS OWN DIFF SPPEDS. SO DIFF CHUNKS SIZE.
BUT IN PARTY MODE, WE CAN EXPECT SLOW SPEEDS. BUT NOW ALWAYS ? WE NEED TO MAXAMIZE IT. SLOWEST CONENCTION WILL BE BOTTLENEXT THERE.
REASTICIALLY, DONT EXPECT 50 PPL. BCZ 50 PPL MEANS EVEN AT 6GHZ NO NOISE. 100MB / (50) = 2. THEN /2 BCZ 2 (BCZ ROUTER IN MIDDLE). = 1MB.
IF 10 PPL = 100 / (10*2) = 5MB.

// REALISTIC STEPS TO DO
1. KEEP 20 SIZE + PARALLELLISM
2. TRY TO OPTOMIZE BY INXREASING (SIZE + PARALLELLISM) AT SAME TIME USING TECHNIQUE I THOUGHT. IF SPEED > X THEN Y. ALWAYS KEEP 1 FLOOR ABOVE.
3. OPTOMIZE FOR PARTY MODE. SO OPTIMIZATION IS. DOWNLOAD AVAILABLE ONES. REGARDLESS OF OUR OWN SPEED. ONLY THEN ASK FILES BASED ON OUR SPEED. AND OUR ALGO. 

 //    CONCLUSIONS
// no speed EFFECT , on loading FILE from UI, or reading from memory, if enough parallel chunks are doing work.

//  WHAT SPEED AND CHUNK SHOULD I USE -> 20MB AND 20 PARALLEL

// we need to increase parallellism, to 20 MAX. if speed is possible. we will do it by comparing them to our expected speeds.
Chunk is always 20MB. Which does cause an issue of pausing.

// ok, so we need to know how to balance parallellism, 
// and 2, know if connection is too slow, then move to 5MB Packets.




//          TRICKS
1. BYPASS HTTP WARNINGS.
[ User Device ]
   ↓  (QR Code)
https://connect.yourdomain.com/init?target=192.168.1.5:8000
   ↓ (Redirect or JS)
http://192.168.1.5:8000  ← Main app runs here