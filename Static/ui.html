<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Client Approval UI</title>
	<style>
		body { font-family: sans-serif; max-width: 800px; margin: auto; }
		.section { margin-bottom: 30px; }
		.client-list { border: 1px solid #ccc; padding: 10px; min-height: 60px; }
		.client { margin-bottom: 8px; }
		.approved { color: green; }
		.not-approved { color: red; }
		button { margin-left: 10px; }
		#status-msg { margin-bottom: 20px; }
	</style>
</head>
<body>
	<h1>Client Approval Panel</h1>
		<div id="status-msg"></div>

		<div id="ui-file-drop" style="border:2px dashed #888; padding:20px; margin:10px 0; text-align:center; background:#f8f8f8; cursor:pointer;">
			<span>Drop files here or <label style="color:blue; text-decoration:underline; cursor:pointer;"><input type="file" id="ui-file-input" multiple style="display:none;">select files</label></span>
		</div>
		<div id="ui-file-list"></div>

	<div class="section">
		<h2>Disapproved Clients</h2>
		<div id="disapproved" class="client-list"></div>
	</div>
	<div class="section">
		<h2>Approved Clients</h2>
		<div id="approved" class="client-list"></div>
	</div>

	<script>
		// Store clients by public_id
		const clients = {};
		const clientFiles = {}; // public_id -> array of files

		// UI file drop for admin
		let uiFileIdCounter = 1;
		const uiFilesArr = [];
		const uiFileListDiv = document.getElementById("ui-file-list");
		const uiFileDrop = document.getElementById("ui-file-drop");
		const uiFileInput = document.getElementById("ui-file-input");

		function renderUiFiles() {
			uiFileListDiv.innerHTML = '';
			if (uiFilesArr.length === 0) return;
			const ul = document.createElement('ul');
				uiFilesArr.forEach(f => {
					const li = document.createElement('li');
					li.textContent = `${f.name} (${f.size} bytes, ${f.type || 'unknown'}) [id: ${f.id}]`;
					// Add remove button
					const btn = document.createElement('button');
					btn.textContent = 'Remove';
					btn.onclick = function(e) {
						e.stopPropagation();
						// Remove file from array
						const idx = uiFilesArr.findIndex(file => file.id === f.id);
						if (idx !== -1) {
							uiFilesArr.splice(idx, 1);
							renderUiFiles();
							// Send opcode 11 to remove file
							if (ws && ws.readyState === WebSocket.OPEN) {
								ws.send(JSON.stringify({ opcode: 11, data: { file_id: f.id, public_id: 0 } }));
							}
						}
					};
					li.appendChild(btn);
					ul.appendChild(li);
				});
			uiFileListDiv.appendChild(ul);
		}

		function handleUiFiles(fileList) {
			let added = [];
			Array.from(fileList).forEach(file => {
				const fileObj = {
					name: file.name,
					id: uiFileIdCounter++,
					size: file.size,
					type: file.type,
					file: file // keep original File object for chunking
				};
				uiFilesArr.push(fileObj);
				added.push(fileObj);
			});
			renderUiFiles();
			// Send opcode 10 with data: {file_count, public_id:0, files: [...]}
			if (ws && ws.readyState === WebSocket.OPEN && added.length > 0) {
				ws.send(JSON.stringify({
					opcode: 10,
					data: {
						file_count: uiFilesArr.length,
						public_id: 0,
						files: uiFilesArr.map(f => {
							// Don't send the File object over websocket
							const {file, ...rest} = f;
							return rest;
						})
					}
				}));
			}
		}

		uiFileDrop.addEventListener('dragover', function(e) {
			e.preventDefault();
			uiFileDrop.style.background = '#e0e0e0';
		});
		uiFileDrop.addEventListener('dragleave', function(e) {
			e.preventDefault();
			uiFileDrop.style.background = '#f8f8f8';
		});
		uiFileDrop.addEventListener('drop', function(e) {
			e.preventDefault();
			uiFileDrop.style.background = '#f8f8f8';
			if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
				handleUiFiles(e.dataTransfer.files);
			}
		});
		uiFileInput.addEventListener('change', function(e) {
			if (uiFileInput.files && uiFileInput.files.length > 0) {
				handleUiFiles(uiFileInput.files);
				uiFileInput.value = '';
			}
		});
		uiFileDrop.querySelector('input[type="file"]').addEventListener('click', function(e) {
			e.stopPropagation();
		});
		uiFileDrop.addEventListener('click', function() {
			uiFileInput.click();
		});

		function showStatus(msg, isError) {
			const status = document.getElementById('status-msg');
			status.textContent = msg;
			status.style.color = isError ? 'red' : 'green';
			if (msg) setTimeout(() => { status.textContent = ''; }, 8000);
		}

		function renderClients() {
			const approvedDiv = document.getElementById('approved');
			const disapprovedDiv = document.getElementById('disapproved');
			approvedDiv.innerHTML = '';
			disapprovedDiv.innerHTML = '';

			Object.values(clients).forEach(client => {
				const div = document.createElement('div');
				div.className = 'client ' + (client.approved ? 'approved' : 'disapproved');
				div.textContent = `ID: ${client.public_id} | Name: ${client.public_name || ''}`;
				div.style.cursor = 'pointer';

				// Show files for this client, if any
				const files = clientFiles[client.public_id];
				if (Array.isArray(files) && files.length > 0) {
					const filesList = document.createElement('ul');
					files.forEach(f => {
						const li = document.createElement('li');
						li.textContent = `${f.name} (${f.size} bytes, ${f.type || 'unknown'}) [id: ${f.id}]`;
						filesList.appendChild(li);
					});
					div.appendChild(document.createElement('br'));
					div.appendChild(filesList);
				}

				if (client.approved) {
					div.title = 'Click to disapprove';
					div.onclick = function() {
						if (ws && ws.readyState === WebSocket.OPEN) {
							ws.send(JSON.stringify({ opcode: 6, data: { public_id: client.public_id } }));
							client.approved = 0;
							renderClients();
						}
					};
					approvedDiv.appendChild(div);
				} else {
					div.title = 'Click to approve';
					div.onclick = function() {
						if (ws && ws.readyState === WebSocket.OPEN) {
							ws.send(JSON.stringify({ opcode: 4, data: { public_id: client.public_id } }));
							client.approved = 1;
							renderClients();
						}
					};
					disapprovedDiv.appendChild(div);
				}
			});
		}

		// WebSocket logic
		let ws;
		function connectWS() {
			ws = new WebSocket('ws://localhost:8080/chat');
			ws.onopen = function() {
				showStatus('WebSocket connected', false);
				// Send initial message: opcode 1, data {}
				ws.send(JSON.stringify({ opcode: 1, data: {} }));
			};
			ws.onmessage = function(event) {
				try {
					const msg = JSON.parse(event.data);
					handleWSMessage(msg);
				} catch (e) {
					showStatus('Invalid message received', true);
				}
			};
			ws.onclose = function() {
				showStatus('WebSocket closed', true);
				// Optionally, try to reconnect after a delay
			};
			ws.onerror = function() {
				showStatus('WebSocket error', true);
			};
		}

		function handleWSMessage(msg) {
			if (!msg || typeof msg.opcode !== 'number') return;
			switch (msg.opcode) {
				case 3:
					// ...existing code...
					if (Array.isArray(msg.data)) {
						msg.data.forEach(c => {
							if (typeof c.public_id === 'number') {
								clients[c.public_id] = {
									public_id: c.public_id,
									private_id: c.private_id || '',
									public_name: c.public_name || '',
									approved: c.approved ? 1 : 0
								};
							}
						});
						renderClients();
					}
					break;
				case 8:
					// ...existing code...
					if (msg.data && typeof msg.data.public_id !== 'undefined' && Array.isArray(msg.data.files)) {
						clientFiles[msg.data.public_id] = msg.data.files;
						renderClients();
					}
					break;
				case 9:
					// ...existing code...
					if (msg.data && typeof msg.data.public_id !== 'undefined' && typeof msg.data.file_id !== 'undefined') {
						const arr = clientFiles[msg.data.public_id];
						if (Array.isArray(arr)) {
							const idx = arr.findIndex(f => f.id === msg.data.file_id);
							if (idx !== -1) {
								arr.splice(idx, 1);
								renderClients();
							}
						}
					}
					break;
				// Handle chunk upload request (opcode 13)
				case 13:
					if (msg.data && typeof msg.data.public_id !== 'undefined' && typeof msg.data.file_id !== 'undefined' && typeof msg.data.chunk_id !== 'undefined') {
						uploadChunkFromUiFiles(msg.data.public_id, msg.data.file_id, msg.data.chunk_id);
					}
					break;
				default:
					// ...existing code...
					break;
			}
		}
		// Upload a chunk from the admin's dropbox files
		function uploadChunkFromUiFiles(public_id, file_id, chunk_id) {
			// Find the file in uiFilesArr
			const file = uiFilesArr.find(f => f.id === file_id);
			if (!file || !file.file) {
				showStatus('File not found for upload', true);
				return;
			}
			const CHUNK_SIZE = 1024 * 1024 * 10;
			const start = chunk_id * CHUNK_SIZE;
			const end = Math.min(start + CHUNK_SIZE, file.size);
			const blob = file.file.slice(start, end);
			// Upload via HTTP POST to /upload_chunk with query params and raw binary body
			const url = `http://localhost:8080/upload_chunk?public_id=${encodeURIComponent(public_id)}&file_id=${encodeURIComponent(file_id)}&chunk_id=${encodeURIComponent(chunk_id)}`;
			fetch(url, {
				method: 'POST',
				headers: {
					'Content-Type': 'application/octet-stream'
				},
				body: blob
			}).then(resp => {
				if (!resp.ok) throw new Error('Upload failed');
				showStatus('Chunk uploaded', false);
			}).catch(err => {
				showStatus('Chunk upload error: ' + err, true);
			});
		}

		// Start WebSocket on page load
		window.onload = connectWS;
	</script>
</body>
</html>
