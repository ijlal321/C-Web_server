<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Client Approval UI</title>
	<style>
		body { font-family: sans-serif; max-width: 800px; margin: auto; }
		.section { margin-bottom: 30px; }
		.client-list { border: 1px solid #ccc; padding: 10px; min-height: 60px; }
		.client { margin-bottom: 8px; }
		.approved { color: green; }
		.not-approved { color: red; }
		button { margin-left: 10px; }
		#status-msg { margin-bottom: 20px; }
	</style>
</head>
<body>
	<h1>Client Approval Panel</h1>
		<div id="status-msg"></div>

		<div id="ui-file-drop" style="border:2px dashed #888; padding:20px; margin:10px 0; text-align:center; background:#f8f8f8; cursor:pointer;">
			<span>Drop files here or <label style="color:blue; text-decoration:underline; cursor:pointer;"><input type="file" id="ui-file-input" multiple style="display:none;">select files</label></span>
		</div>
		<div id="ui-file-list"></div>

	<div class="section">
		<h2>Disapproved Clients</h2>
		<div id="disapproved" class="client-list"></div>
	</div>
	<div class="section">
		<h2>Approved Clients</h2>
		<div id="approved" class="client-list"></div>
	</div>

	<script>

		const CHUNK_SIZE = 1024 * 1024 * 20;
		const MAX_PARALLEL_CHUNKS = 20;
		const downloadState = {};

		// Store clients by public_id
		const clients = {};
		const clientFiles = {}; // public_id -> array of files

		// UI file drop for admin
		let uiFileIdCounter = 1;
		const uiFilesArr = [];
		const uiFileListDiv = document.getElementById("ui-file-list");
		const uiFileDrop = document.getElementById("ui-file-drop");
		const uiFileInput = document.getElementById("ui-file-input");

		function renderUiFiles() {
			uiFileListDiv.innerHTML = '';
			if (uiFilesArr.length === 0) return;
			const ul = document.createElement('ul');
				uiFilesArr.forEach(f => {
					const li = document.createElement('li');
					li.textContent = `${f.name} (${f.size} bytes, ${f.type || 'unknown'}) [id: ${f.id}]`;
					// Add remove button
					const btn = document.createElement('button');
					btn.textContent = 'Remove';
					btn.onclick = function(e) {
						e.stopPropagation();
						// Remove file from array
						const idx = uiFilesArr.findIndex(file => file.id === f.id);
						if (idx !== -1) {
							uiFilesArr.splice(idx, 1);
							renderUiFiles();
							// Send opcode 11 to remove file
							if (ws && ws.readyState === WebSocket.OPEN) {
								ws.send(JSON.stringify({ opcode: 11, data: { file_id: f.id, public_id: 0 } }));
							}
						}
					};
					li.appendChild(btn);
					ul.appendChild(li);
				});
			uiFileListDiv.appendChild(ul);
		}

		function handleUiFiles(fileList) {
			let added = [];
			Array.from(fileList).forEach(file => {
				const fileObj = {
					name: file.name,
					id: uiFileIdCounter++,
					size: file.size,
					type: file.type,
					file: file // keep original File object for chunking
				};
				uiFilesArr.push(fileObj);
				added.push(fileObj);
			});
			renderUiFiles();
			// Send opcode 10 with data: {file_count, public_id:0, files: [...]}
			if (ws && ws.readyState === WebSocket.OPEN && added.length > 0) {
				ws.send(JSON.stringify({
					opcode: 10,
					data: {
						file_count: uiFilesArr.length,
						public_id: 0,
						files: uiFilesArr.map(f => {
							// Don't send the File object over websocket
							const {file, ...rest} = f;
							return rest;
						})
					}
				}));
			}
		}

		uiFileDrop.addEventListener('dragover', function(e) {
			e.preventDefault();
			uiFileDrop.style.background = '#e0e0e0';
		});
		uiFileDrop.addEventListener('dragleave', function(e) {
			e.preventDefault();
			uiFileDrop.style.background = '#f8f8f8';
		});
		uiFileDrop.addEventListener('drop', function(e) {
			e.preventDefault();
			uiFileDrop.style.background = '#f8f8f8';
			if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
				handleUiFiles(e.dataTransfer.files);
			}
		});
		uiFileInput.addEventListener('change', function(e) {
			if (uiFileInput.files && uiFileInput.files.length > 0) {
				handleUiFiles(uiFileInput.files);
				uiFileInput.value = '';
			}
		});
		uiFileDrop.querySelector('input[type="file"]').addEventListener('click', function(e) {
			e.stopPropagation();
		});
		uiFileDrop.addEventListener('click', function() {
			uiFileInput.click();
		});

		function showStatus(msg, isError) {
			const status = document.getElementById('status-msg');
			status.textContent = msg;
			status.style.color = isError ? 'red' : 'green';
			if (msg) setTimeout(() => { status.textContent = ''; }, 8000);
		}

	
		function renderClients() {
			const approvedDiv = document.getElementById('approved');
			const disapprovedDiv = document.getElementById('disapproved');
			approvedDiv.innerHTML = '';
			disapprovedDiv.innerHTML = '';

			Object.values(clients).forEach(client => {
				const div = document.createElement('div');
				div.className = 'client ' + (client.approved ? 'approved' : 'disapproved');
				div.textContent = `ID: ${client.public_id} | Name: ${client.public_name || ''}`;
				div.style.cursor = 'pointer';

				// Show files for this client, if any
				const files = clientFiles[client.public_id];
				if (Array.isArray(files) && files.length > 0) {
					const filesList = document.createElement('ul');
					files.forEach((f, idx) => {
						const li = document.createElement('li');
						li.textContent = `${f.name} (${f.size} bytes, ${f.type || 'unknown'}) [id: ${f.id}]`;
						// Only show download button for files from clients (not admin/public_id 0)
						if (client.public_id !== 0) {
							const btn = document.createElement('button');
							btn.textContent = 'Download';
							btn.onclick = function(e) {
								e.stopPropagation();
								// Parallel chunked download logic (like chat2.html)
								const totalChunks = Math.ceil(f.size / CHUNK_SIZE);
								const fileKey = client.public_id + ':' + f.id;
								downloadState[fileKey] = {
									chunks: Array(totalChunks).fill(null),
									received: Array(totalChunks).fill(false),
									totalChunks,
									fileName: f.name,
									fileSize: f.size,
									next_Chunk_index: MAX_PARALLEL_CHUNKS,
									completed: 0,
									downloadStartTime: Date.now(),
									btn: btn
								};
								// Send MAX_PARALLEL_CHUNKS requests for this file
								for (let i = 0; i < Math.min(MAX_PARALLEL_CHUNKS, totalChunks); ++i) {
									send_chunk_request(client.public_id, f.id, i);
								}
							};
							li.appendChild(btn);
						}
						filesList.appendChild(li);
					});
					div.appendChild(document.createElement('br'));
					div.appendChild(filesList);
				}

				if (client.approved) {
					div.title = 'Click to disapprove';
					div.onclick = function () {
						if (ws && ws.readyState === WebSocket.OPEN) {
							ws.send(JSON.stringify({ opcode: 6, data: { public_id: client.public_id } }));
							client.approved = 0;
							renderClients();
						}
					};
					approvedDiv.appendChild(div);
				} else {
					div.title = 'Click to approve';
					div.onclick = function () {
						if (ws && ws.readyState === WebSocket.OPEN) {
							ws.send(JSON.stringify({ opcode: 4, data: { public_id: client.public_id } }));
							client.approved = 1;
							renderClients();
						}
					};
					disapprovedDiv.appendChild(div);
				}
			});
		}

		// WebSocket logic
		let ws;
		function connectWS() {
			ws = new WebSocket('ws://localhost:8080/chat');
			ws.onopen = function() {
				showStatus('WebSocket connected', false);
				// Send initial message: opcode 1, data {}
				ws.send(JSON.stringify({ opcode: 1, data: {} }));
			};
			ws.onmessage = function(event) {
				try {
					const msg = JSON.parse(event.data);
					handleWSMessage(msg);
				} catch (e) {
					showStatus('Invalid message received: ' + e, true);
				}
			};
			ws.onclose = function() {
				showStatus('WebSocket closed', true);
				// Optionally, try to reconnect after a delay
			};
			ws.onerror = function() {
				showStatus('WebSocket error', true);
			};
		}

		function handleWSMessage(msg) {
			if (!msg || typeof msg.opcode !== 'number') return;
			switch (msg.opcode) {
				case 3:
					// ...existing code...
					if (Array.isArray(msg.data)) {
						msg.data.forEach(c => {
							if (typeof c.public_id === 'number') {
								clients[c.public_id] = {
									public_id: c.public_id,
									private_id: c.private_id || '',
									public_name: c.public_name || '',
									approved: c.approved ? 1 : 0
								};
							}
						});
						renderClients();
					}
					break;
				case 8:
					// Add files from client.
					if (msg.data && typeof msg.data.public_id !== 'undefined' && Array.isArray(msg.data.files)) {
						if (!Array.isArray(clientFiles[msg.data.public_id])) {
							clientFiles[msg.data.public_id] = [];
						}
						clientFiles[msg.data.public_id].push(...msg.data.files);
						renderClients();
					}
					break;
				case 9:
					// ...existing code...
					if (msg.data && typeof msg.data.public_id !== 'undefined' && typeof msg.data.file_id !== 'undefined') {
						const arr = clientFiles[msg.data.public_id];
						if (Array.isArray(arr)) {
							const idx = arr.findIndex(f => f.id === msg.data.file_id);
							if (idx !== -1) {
								arr.splice(idx, 1);
								renderClients();
							}
						}
					}
					break;
				// Handle chunk upload request (opcode 13)
				case 13:
					if (msg.data && typeof msg.data.owner_public_id !== 'undefined' && typeof msg.data.file_id !== 'undefined' && typeof msg.data.start_pos !== 'undefined' && typeof msg.data.size !== 'undefined') {
						uploadChunkFromUiFiles(msg.data.owner_public_id, msg.data.file_id, msg.data.start_pos, msg.data.size);
					}
					break;
				case 14:
					if (msg.data && typeof msg.data.public_id !== 'undefined' && typeof msg.data.file_id !== 'undefined' && typeof msg.data.chunk_id !== 'undefined') {
						download_chunk(msg);
					}
					break;
				default:
					// ...existing code...
					break;
			}
		}
		// Upload a chunk from the admin's dropbox files
		function uploadChunkFromUiFiles(owner_public_id, file_id, start_pos, size) {
			// Todo: owner public id must be 0 here. bcz 0 is always UI app. For Future.
			// Find the file in uiFilesArr
			const file = uiFilesArr.find(f => f.id == file_id);
			if (!file || !file.file) {
				showStatus('File not found for upload', true);
				return;
			}
			const end = Math.min(start_pos + size, file.size);
			const blob = file.file.slice(start_pos, end);  // remember end is exclusive

			// Upload via HTTP POST to /upload_chunk with query params and raw binary body
			const url = `http://localhost:8080/upload_chunk?owner_public_id=${encodeURIComponent(owner_public_id)}&file_id=${encodeURIComponent(file_id)}&start_pos=${encodeURIComponent(start_pos)}&size=${encodeURIComponent(size)}`;
			fetch(url, {
				method: 'POST',
				headers: {
					'Content-Type': 'application/octet-stream'
				},
				body: blob
			}).then(resp => {
				if (!resp.ok) {
					showStatus('Chunk Upload Error. Response from http failed', true);
					return;
				};
				showStatus('Chunk uploaded', false);
			}).catch(err => {
				showStatus('Chunk upload error: ' + err, true);
			});
		}

				// Listen for chunk ready (opcode 14) and download chunk
		function download_chunk(msg) {
			const { public_id, file_id, chunk_id } = msg.data;
			const fileKey = public_id + ':' + file_id;
			const state = downloadState[fileKey];
			if (!state) {
				console.warn("No download state for fileKey", fileKey);
				return;
			}
			if (state.chunks[chunk_id] != null) {
				console.warn("Already Got File Chunk?", fileKey, chunk_id);
				return;
			}
			const url = `http://localhost:8080/download_chunk?public_id=${encodeURIComponent(public_id)}&file_id=${encodeURIComponent(file_id)}&chunk_id=${encodeURIComponent(chunk_id)}`;
			fetch(url)
				.then(resp => resp.ok ? resp.arrayBuffer() : Promise.reject('Failed to download chunk'))
				.then(buf => {
					state.chunks[chunk_id] = buf;
					state.received[chunk_id] = true;
					state.completed++;
					// Check if all chunks are received
					if (state.completed === state.totalChunks) {
						const blob = new Blob(state.chunks, { type: 'application/octet-stream' });
						const a = document.createElement('a');
						a.href = URL.createObjectURL(blob);
						a.download = state.fileName;
						a.click();
						if (state.downloadStartTime && state.btn) {
							const elapsed = ((Date.now() - state.downloadStartTime) / 1000).toFixed(2);
							state.btn.textContent = `Download (Done in ${elapsed}s)`;
						}
						delete downloadState[fileKey];
						console.log('File download complete:', state.fileName);
					} else {
						// Request the next chunk if not completed
						const next_chunk_id = state.next_Chunk_index++;
						if (next_chunk_id < state.totalChunks) {
							send_chunk_request(public_id, file_id, next_chunk_id);
						}
					}
				})
				.catch(err => {
					console.warn('Chunk download failed:', err);
				});
		}

						// --- Parallel chunked download logic (like chat2.html) ---
		function send_chunk_request(public_id, file_id, chunk_id) {
			if (ws && ws.readyState === WebSocket.OPEN) {
				ws.send(JSON.stringify({
					opcode: 12,
					data: {
						sender_public_id: 0,
						public_id: Number(public_id),
						file_id: file_id,
						chunk_id: chunk_id
					}
				}));
			}
		}
		// Start WebSocket on page load
		window.onload = connectWS;
	</script>
</body>
</html>
