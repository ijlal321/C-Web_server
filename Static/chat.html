<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Simple WebSocket Chat</title>
  <style>
    body { font-family: sans-serif; max-width: 600px; margin: auto; }
    #chat { border: 1px solid #ccc; padding: 10px; height: 300px; overflow-y: auto; }
    #msg { width: 80%; }
  </style>
</head>
<body>
  <h1>Chat Room</h1>

  <div id="state"></div>
  <div id="file-drop" style="border:2px dashed #888; padding:20px; margin:10px 0; text-align:center; background:#f8f8f8; cursor:pointer;">
    <span>Drop files here or <label style="color:blue; text-decoration:underline; cursor:pointer;"><input type="file" id="file-input" multiple style="display:none;">select files</label></span>
  </div>
  <div id="file-list"></div>
  <div id="chat"></div>
  <input id="msg" placeholder="Type a message...">
  <button onclick="send()">Send</button>


  <script>
    // File handling
    let fileIdCounter = 1;
    const filesArr = [];
    const fileListDiv = document.getElementById("file-list");
    const fileDrop = document.getElementById("file-drop");
    const fileInput = document.getElementById("file-input");

    // Store files received from websocket by public_id
    const wsFilesByPublicId = {};

    function renderFiles() {
      fileListDiv.innerHTML = '';
      // Show own files (removable)
      if (filesArr.length > 0) {
        const ul = document.createElement('ul');
        filesArr.forEach(f => {
          const li = document.createElement('li');
          li.textContent = `${f.name} (${f.size} bytes, ${f.type || 'unknown'}) [id: ${f.id}]`;
          li.style.cursor = 'pointer';
          li.title = 'Click to remove this file';
          li.onclick = function() {
            // Remove file from array
            const idx = filesArr.findIndex(file => file.id === f.id);
            if (idx !== -1) {
              filesArr.splice(idx, 1);
              renderFiles();
              // Send opcode 9 to remove file
              if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ opcode: 9, data: { file_id: f.id, public_id: public_id } }));
              }
            }
          };
          ul.appendChild(li);
        });
        const label = document.createElement('div');
        label.textContent = 'Your Files:';
        fileListDiv.appendChild(label);
        fileListDiv.appendChild(ul);
      }
      // Show files received from websocket (not removable)
      Object.entries(wsFilesByPublicId).forEach(([pid, files]) => {
        if (Array.isArray(files) && files.length > 0) {
          const label = document.createElement('div');
          label.textContent = `Files from public_id ${pid}:`;
          const ul = document.createElement('ul');
          files.forEach(f => {
            const li = document.createElement('li');
            li.textContent = `${f.name} (${f.size} bytes, ${f.type || 'unknown'}) [id: ${f.id}]`;
            ul.appendChild(li);
          });
          fileListDiv.appendChild(label);
          fileListDiv.appendChild(ul);
        }
      });
    }

    let public_id = null;
    function handleFiles(fileList) {
      let added = [];
      Array.from(fileList).forEach(file => {
        const fileObj = {
          name: file.name,
          id: fileIdCounter++,
          size: file.size,
          type: file.type
        };
        filesArr.push(fileObj);
        added.push(fileObj);
      });
      renderFiles();
      // Send opcode 8 with data: {file_count, public_id, files: [...]}
      if (ws && ws.readyState === WebSocket.OPEN && added.length > 0) {
        ws.send(JSON.stringify({
          opcode: 8,
          data: {
            file_count: filesArr.length,
            public_id: public_id,
            files: filesArr
          }
        }));
      }
    }

    fileDrop.addEventListener('dragover', function(e) {
      e.preventDefault();
      fileDrop.style.background = '#e0e0e0';
    });
    fileDrop.addEventListener('dragleave', function(e) {
      e.preventDefault();
      fileDrop.style.background = '#f8f8f8';
    });
    fileDrop.addEventListener('drop', function(e) {
      e.preventDefault();
      fileDrop.style.background = '#f8f8f8';
      if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
        handleFiles(e.dataTransfer.files);
      }
    });
    fileInput.addEventListener('change', function(e) {
      if (fileInput.files && fileInput.files.length > 0) {
        handleFiles(fileInput.files);
        fileInput.value = '';
      }
    });
    fileDrop.querySelector('input[type="file"]').addEventListener('click', function(e) {
      e.stopPropagation();
    });
    fileDrop.addEventListener('click', function() {
      fileInput.click();
    });

    const chat = document.getElementById("chat");
    const msg = document.getElementById("msg");
    const stateDiv = document.getElementById("state");
    let approved = false;

    function renderState() {
      stateDiv.textContent = "Approved: " + (approved ? "Yes" : "No");
      stateDiv.style.color = approved ? "green" : "red";
    }

    // Replace this with the actual private_key you want to send
    function generateRandomId() {
      let arr = new Uint8Array(16); // 16 bytes = 32 hex chars
      window.crypto.getRandomValues(arr);
      return Array.from(arr, b => b.toString(16).padStart(2, '0')).join('');
    }

    const private_key = generateRandomId();
    // const ws = new WebSocket("ws://localhost:8080/chat");
       const ws = new WebSocket(`ws://${window.location.hostname}:8080/chat`);

    ws.onopen = function() {
      // Send registration message after connection established
      ws.send(JSON.stringify({
        opcode: 0,
        data: { private_key: private_key }
      }));
    };

    ws.onmessage = function(event) {
      try {
        const message = JSON.parse(event.data);
        if (typeof message === "object" && "opcode" in message && "data" in message) {
          if (message.opcode === 2) {
            // Accept public_id from server
            if (typeof message.data === 'object' && 'public_id' in message.data) {
              public_id = message.data.public_id;
            }
          } else if (message.opcode === 5) {
            approved = true;
            renderState();
          } else if (message.opcode === 7) {
            approved = false;
            renderState();
          } else if (message.opcode === 10) {
            // Add files from websocket for a public_id
            if (message.data && typeof message.data.public_id !== 'undefined' && Array.isArray(message.data.files)) {
              wsFilesByPublicId[message.data.public_id] = message.data.files;
              renderFiles();
            }
          } else if (message.opcode === 11) {
            // Remove file from wsFilesByPublicId for the given public_id
            if (message.data && typeof message.data.public_id !== 'undefined' && typeof message.data.file_id !== 'undefined') {
              const arr = wsFilesByPublicId[message.data.public_id];
              if (Array.isArray(arr)) {
                const idx = arr.findIndex(f => f.id === message.data.file_id);
                if (idx !== -1) {
                  arr.splice(idx, 1);
                  renderFiles();
                }
              }
            }
            // Also remove from own files if public_id matches
            if (message.data && typeof message.data.public_id !== 'undefined' && typeof message.data.file_id !== 'undefined') {
              if (public_id !== null && message.data.public_id === public_id) {
                const idx = filesArr.findIndex(f => f.id === message.data.file_id);
                if (idx !== -1) {
                  filesArr.splice(idx, 1);
                  renderFiles();
                }
              }
            }
          }
          const line = document.createElement("div");
          line.textContent = `[opcode: ${message.opcode}] ${JSON.stringify(message.data)}`;
          chat.appendChild(line);
          chat.scrollTop = chat.scrollHeight;
        }
      } catch (e) {
        // Ignore non-JSON messages
      }
    };

    function send() {
      if (msg.value) {
        ws.send(JSON.stringify({
          opcode: 1, // Example opcode for chat message
          data: { text: msg.value }
        }));
        msg.value = "";
      }
    }

    msg.addEventListener("keypress", function(e) {
      if (e.key === "Enter") send();
    });

    // Start WebSocket and state display on page load
    window.onload = function() {
      renderState();
    };
  </script>
</body>
</html>