<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Simple WebSocket Chat</title>
  <style>
    body { font-family: sans-serif; max-width: 600px; margin: auto; }
    #chat { border: 1px solid #ccc; padding: 10px; height: 300px; overflow-y: auto; }
    #msg { width: 80%; }
  </style>
</head>
<body>
  <h1>Chat Room</h1>

  <div id="state"></div>
  <div id="file-drop" style="border:2px dashed #888; padding:20px; margin:10px 0; text-align:center; background:#f8f8f8; cursor:pointer;">
    <span>Drop files here or <label style="color:blue; text-decoration:underline; cursor:pointer;"><input type="file" id="file-input" multiple style="display:none;">select files</label></span>
  </div>
  <div id="file-list"></div>
  <div id="chat"></div>
  <input id="msg" placeholder="Type a message...">
  <button onclick="send()">Send</button>


  <script>
    // File handling
    let fileIdCounter = 1;
    const filesArr = [];
    const fileListDiv = document.getElementById("file-list");
    const fileDrop = document.getElementById("file-drop");
    const fileInput = document.getElementById("file-input");

    // Store files received from websocket by public_id
    const wsFilesByPublicId = {};

    function renderFiles() {
      fileListDiv.innerHTML = '';
      // Show own files (removable)
      if (filesArr.length > 0) {
        const ul = document.createElement('ul');
        filesArr.forEach(f => {
          const li = document.createElement('li');
          li.textContent = `${f.name} (${f.size} bytes, ${f.type || 'unknown'}) [id: ${f.id}]`;
          li.style.cursor = 'pointer';
          li.title = 'Click to remove this file';
          li.onclick = function() {
            // Remove file from array
            const idx = filesArr.findIndex(file => file.id === f.id);
            if (idx !== -1) {
              filesArr.splice(idx, 1);
              renderFiles();
              // Send opcode 9 to remove file
              if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ opcode: 9, data: { file_id: f.id, public_id: public_id } }));
              }
            }
          };
          ul.appendChild(li);
        });
        const label = document.createElement('div');
        label.textContent = 'Your Files:';
        fileListDiv.appendChild(label);
        fileListDiv.appendChild(ul);
      }
      // Show files received from websocket (with download button)
      Object.entries(wsFilesByPublicId).forEach(([pid, files]) => {
        if (Array.isArray(files) && files.length > 0) {
          const label = document.createElement('div');
          label.textContent = `Files from public_id ${pid}:`;
          const ul = document.createElement('ul');
          files.forEach(f => {
            const li = document.createElement('li');
            li.textContent = `${f.name} (${f.size} bytes, ${f.type || 'unknown'}) [id: ${f.id}]`;
            // Add download button
            const btn = document.createElement('button');
            btn.textContent = 'Download';
            btn.onclick = function() {
              startFileDownload({
                sender_public_id: pid,
                file_id: f.id,
                file_name: f.name,
                file_size: f.size
              });
            };
            li.appendChild(btn);
            ul.appendChild(li);
          });
          fileListDiv.appendChild(label);
          fileListDiv.appendChild(ul);
        }
      });
    }

    // Download logic
    const CHUNK_SIZE = 1024 * 1024 * 10; // 1MB
    const MAX_PARALLEL_CHUNKS = 200;
    // Map: fileKey -> {chunks: [], received: [], totalChunks, fileName, fileSize, senderPublicId}
    const downloadState = {};

    function startFileDownload({sender_public_id, file_id, file_name, file_size}) {
      const fileKey = sender_public_id + ':' + file_id;
      if (downloadState[fileKey]) return; // Already downloading
      const totalChunks = Math.ceil(file_size / CHUNK_SIZE);
      downloadState[fileKey] = {
        chunks: Array(totalChunks).fill(null),
        received: Array(totalChunks).fill(false),
        totalChunks,
        fileName: file_name,
        fileSize: file_size,
        senderPublicId: sender_public_id,
        fileId: file_id,
        nextChunk: 0,
        completed: 0
      };
      // Request first 4 chunks
      for (let i = 0; i < Math.min(MAX_PARALLEL_CHUNKS, totalChunks); ++i) {
        requestChunk(fileKey, i);
      }
    }

    function requestChunk(fileKey, chunkId) {
      const state = downloadState[fileKey];
      if (!state) return;
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          opcode: 12,
          data: {
            // sender_public_id: state.senderPublicId,
            // public_id: public_id,
            sender_public_id: public_id, // sender public id means its own 
            public_id: state.senderPublicId, // here public id means the owner public id
            file_id: state.fileId,
            chunk_id: chunkId
          }
        }));
      }
    }

    function handleChunkReady(data) {
      // data: {public_id, file_id, chunk_id}
      const fileKey = data.public_id + ':' + data.file_id;
      const state = downloadState[fileKey];
      if (!state) return;
      // Download chunk via HTTP
      const url = `/download_chunk?public_id=${encodeURIComponent(data.public_id)}&file_id=${encodeURIComponent(data.file_id)}&chunk_id=${encodeURIComponent(data.chunk_id)}`;
      fetch(url)
        .then(resp => resp.ok ? resp.arrayBuffer() : Promise.reject('Failed to download chunk'))
        .then(buf => {
          // Only store up to CHUNK_SIZE bytes
          let chunkBuf = buf;
          if (buf.byteLength > CHUNK_SIZE) {
            chunkBuf = buf.slice(0, CHUNK_SIZE);
          }
          state.chunks[data.chunk_id] = chunkBuf;
          state.received[data.chunk_id] = true;
          state.completed++;
          // Request next chunk if any
          let next = state.nextChunk;
          while (next < state.totalChunks && state.received[next]) next++;
          if (next < state.totalChunks) {
            state.nextChunk = next + 1;
            requestChunk(fileKey, next);
          }
          // If all chunks received, join and download
          if (state.completed === state.totalChunks) {
            const blob = new Blob(state.chunks, {type: 'application/octet-stream'});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = state.fileName;
            a.click();
            delete downloadState[fileKey];
          }
        })
        .catch(err => {
          alert('Chunk download failed: ' + err);
        });
    }

    let public_id = null;
    function handleFiles(fileList) {
      let added = [];
      Array.from(fileList).forEach(file => {
        const fileObj = {
          name: file.name,
          id: fileIdCounter++,
          size: file.size,
          type: file.type
        };
        filesArr.push(fileObj);
        added.push(fileObj);
      });
      renderFiles();
      // Send opcode 8 with data: {file_count, public_id, files: [...]}
      if (ws && ws.readyState === WebSocket.OPEN && added.length > 0) {
        ws.send(JSON.stringify({
          opcode: 8,
          data: {
            file_count: filesArr.length,
            public_id: public_id,
            files: filesArr
          }
        }));
      }
    }

    fileDrop.addEventListener('dragover', function(e) {
      e.preventDefault();
      fileDrop.style.background = '#e0e0e0';
    });
    fileDrop.addEventListener('dragleave', function(e) {
      e.preventDefault();
      fileDrop.style.background = '#f8f8f8';
    });
    fileDrop.addEventListener('drop', function(e) {
      e.preventDefault();
      fileDrop.style.background = '#f8f8f8';
      if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
        handleFiles(e.dataTransfer.files);
      }
    });
    fileInput.addEventListener('change', function(e) {
      if (fileInput.files && fileInput.files.length > 0) {
        handleFiles(fileInput.files);
        fileInput.value = '';
      }
    });
    fileDrop.querySelector('input[type="file"]').addEventListener('click', function(e) {
      e.stopPropagation();
    });
    fileDrop.addEventListener('click', function() {
      fileInput.click();
    });

    const chat = document.getElementById("chat");
    const msg = document.getElementById("msg");
    const stateDiv = document.getElementById("state");
    let approved = false;

    function renderState() {
      stateDiv.textContent = "Approved: " + (approved ? "Yes" : "No");
      stateDiv.style.color = approved ? "green" : "red";
    }

    // Replace this with the actual private_key you want to send
    function generateRandomId() {
      let arr = new Uint8Array(16); // 16 bytes = 32 hex chars
      window.crypto.getRandomValues(arr);
      return Array.from(arr, b => b.toString(16).padStart(2, '0')).join('');
    }

    const private_key = generateRandomId();
    // const ws = new WebSocket("ws://localhost:8080/chat");
       const ws = new WebSocket(`ws://${window.location.hostname}:8080/chat`);

    ws.onopen = function() {
      // Send registration message after connection established
      ws.send(JSON.stringify({
        opcode: 0,
        data: { private_key: private_key }
      }));
    };

    ws.onmessage = function(event) {
      try {
        const message = JSON.parse(event.data);
        if (typeof message === "object" && "opcode" in message && "data" in message) {
          if (message.opcode === 2) {
            // Accept public_id from server
            if (typeof message.data === 'object' && 'public_id' in message.data) {
              public_id = message.data.public_id;
            }
          } else if (message.opcode === 5) {
            approved = true;
            renderState();
          } else if (message.opcode === 7) {
            approved = false;
            renderState();
          } else if (message.opcode === 10) {
            // Add files from websocket for a public_id
            if (message.data && typeof message.data.public_id !== 'undefined' && Array.isArray(message.data.files)) {
              wsFilesByPublicId[message.data.public_id] = message.data.files;
              renderFiles();
            }
          } else if (message.opcode == 14) {
            // Chunk ready, trigger HTTP download and next request
            handleChunkReady(message.data);
          } else if (message.opcode === 11) {
            // Remove file from wsFilesByPublicId for the given public_id
            if (message.data && typeof message.data.public_id !== 'undefined' && typeof message.data.file_id !== 'undefined') {
              const arr = wsFilesByPublicId[message.data.public_id];
              if (Array.isArray(arr)) {
                const idx = arr.findIndex(f => f.id === message.data.file_id);
                if (idx !== -1) {
                  arr.splice(idx, 1);
                  renderFiles();
                }
              }
            }
            // Also remove from own files if public_id matches
            if (message.data && typeof message.data.public_id !== 'undefined' && typeof message.data.file_id !== 'undefined') {
              if (public_id !== null && message.data.public_id === public_id) {
                const idx = filesArr.findIndex(f => f.id === message.data.file_id);
                if (idx !== -1) {
                  filesArr.splice(idx, 1);
                  renderFiles();
                }
              }
            }
          }
          const line = document.createElement("div");
          line.textContent = `[opcode: ${message.opcode}] ${JSON.stringify(message.data)}`;
          chat.appendChild(line);
          chat.scrollTop = chat.scrollHeight;
        }
      } catch (e) {
        // Ignore non-JSON messages
      }
    };

    function send() {
      if (msg.value) {
        ws.send(JSON.stringify({
          opcode: 1, // Example opcode for chat message
          data: { text: msg.value }
        }));
        msg.value = "";
      }
    }

    msg.addEventListener("keypress", function(e) {
      if (e.key === "Enter") send();
    });

    // Start WebSocket and state display on page load
    window.onload = function() {
      renderState();
    };
  </script>
</body>
</html>