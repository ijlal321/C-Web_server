	
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>File List WebSocket Client</title>
	<style>
		body { font-family: sans-serif; max-width: 600px; margin: auto; }
		#file-list { margin-top: 20px; }
		.file-entry { margin-bottom: 10px; }
		button { margin-left: 10px; }
	</style>
</head>
<body>
	<h2>File List (from WebSocket)</h2>
	<div id="file-list"></div>
	<script>
		// Generate random private_key
		function generateRandomId() {
			let arr = new Uint8Array(16);
			window.crypto.getRandomValues(arr);
			return Array.from(arr, b => b.toString(16).padStart(2, '0')).join('');
		}
		const private_key = generateRandomId();

		// Store files by public_id
		const filesByPublicId = {};

		const MAX_PARALLEL_CHUNKS = 4;
		const CHUNK_SIZE = 1024 * 1024 * 5;
		let my_public_id = -1;

		// Track download state for each file: fileKey -> {chunks, received, totalChunks, fileName, fileSize}
		const downloadState = {};

		// Map: fileKey -> {chunks: [], received: [], totalChunks, fileName, fileSize, completed}
		// Connect to WebSocket
		const ws = new WebSocket(`ws://${window.location.hostname}:8080/chat`);
		ws.onopen = function() {
			ws.send(JSON.stringify({ opcode: 0, data: { private_key } }));
		};

		ws.onmessage = function(event) {
			try {
				const msg = JSON.parse(event.data);
				if (msg.opcode === 10 && msg.data && typeof msg.data.public_id !== 'undefined' && Array.isArray(msg.data.files)) {
					filesByPublicId[msg.data.public_id] = msg.data.files;
					renderFiles();
				}else if (msg.opcode === 2) {
					// Accept public_id from server
					if (typeof msg.data === 'object' && 'public_id' in msg.data) {
						my_public_id = msg.data.public_id;
						console.log("id receid\ved : ", msg.data.public_id);
					}
				}
				// Download functionality removed for now
			} catch (e) {
				// Ignore non-JSON
			}
		}

		function send_chunk_request(public_id, file_id, chunk_id) {
			ws.send(JSON.stringify({
				opcode: 12,
				data: {
					sender_public_id: my_public_id == -1 ? 1 : my_public_id,
					public_id: Number(public_id),
					file_id: file_id,
					chunk_id: chunk_id
				}
			}));
			console.log("reqesut for id: " , chunk_id, " is sent");
		}


		function renderFiles() {
			const fileListDiv = document.getElementById('file-list');
			fileListDiv.innerHTML = '';
			Object.entries(filesByPublicId).forEach(([public_id, files]) => {
				if (Array.isArray(files) && files.length > 0) {
					const label = document.createElement('div');
					label.textContent = `Files from public_id ${public_id}:`;
					fileListDiv.appendChild(label);
					files.forEach(f => {
						const entry = document.createElement('div');
						entry.className = 'file-entry';
						entry.textContent = `${f.name} (${f.size} bytes, ${f.type || 'unknown'}) [id: ${f.id}]`;
						const btn = document.createElement('button');
						btn.textContent = 'Download';
						btn.onclick = function() {
							// Calculate total chunks for this file
							const totalChunks = Math.ceil(f.size / CHUNK_SIZE);
							const fileKey = public_id + ':' + f.id;
							// Allocate space for chunks and received flags
							downloadState[fileKey] = {
								chunks: Array(totalChunks).fill(null),
								received: Array(totalChunks).fill(false),
								totalChunks,
								fileName: f.name,
								fileSize: f.size,
								next_Chunk_index : MAX_PARALLEL_CHUNKS,
								completed: 0
							};
							// Send MAX_PARALLEL_CHUNKS requests for this file
							for (let i = 0; i < Math.min(MAX_PARALLEL_CHUNKS, totalChunks); ++i) {
								send_chunk_request(public_id, f.id, i)
							}
						};
						entry.appendChild(btn);
						fileListDiv.appendChild(entry);
					});
				}
			});
		}
	</script>
</body>
</html>
