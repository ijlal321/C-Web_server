	
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>File List WebSocket Client</title>
	<style>
		body { font-family: sans-serif; max-width: 600px; margin: auto; }
		#file-list { margin-top: 20px; }
		.file-entry { margin-bottom: 10px; }
		button { margin-left: 10px; }
	</style>
</head>
<body>
	<h2>File List (from WebSocket)</h2>
	<div id="file-list"></div>
	<script>
		// Generate random private_id
		function generateRandomId() {
			let arr = new Uint8Array(16);
			window.crypto.getRandomValues(arr);
			return Array.from(arr, b => b.toString(16).padStart(2, '0')).join('');
		}
		const private_id = generateRandomId();

		// Store files by public_id
		const filesByPublicId = {};

		const CHUNK_SIZE = 1024 * 1024 * 20;
		const MAX_PARALLEL_CHUNKS = 20;
		let my_public_id = -1;

		// Track download state for each file: fileKey -> {chunks, received, totalChunks, fileName, fileSize}
		const downloadState = {};

		// Map: fileKey -> {chunks: [], received: [], totalChunks, fileName, fileSize, completed}
		// Connect to WebSocket
		const ws = new WebSocket(`ws://${window.location.hostname}:8080/chat`);
		ws.onopen = function() {
			ws.send(JSON.stringify({ opcode: 0, data: { private_id } }));
		};

		ws.onmessage = function(event) {
			try {
				const msg = JSON.parse(event.data);
				if (msg.opcode === 10 && msg.data && typeof msg.data.public_id !== 'undefined' && Array.isArray(msg.data.files)) {
					filesByPublicId[msg.data.public_id] = msg.data.files;
					renderFiles();
				} else if (msg.opcode === 2) {
					// Accept public_id from server
					if (typeof msg.data === 'object' && 'public_id' in msg.data) {
						my_public_id = msg.data.public_id;
						console.log("id received : ", msg.data.public_id);
					}
				} else if (msg.opcode === 14 && msg.data && typeof msg.data.public_id !== 'undefined' && typeof msg.data.file_id !== 'undefined' && typeof msg.data.chunk_id !== 'undefined') {
					download_chunk(msg);
				}
			} catch (e) {
				// Ignore non-JSON
			}
		}

		function download_chunk(msg) {
			// Download chunk via HTTP and save it
			const { public_id, file_id, chunk_id } = msg.data;
			const fileKey = public_id + ':' + file_id;
			const state = downloadState[fileKey];
			if (!state) {
				console.warn("No download state for fileKey", fileKey);
				return;
			}
			if (state.chunks[chunk_id] != null){
				console.warn("Already Got File Chunk ?", fileKey, chunk_id);
				return;
			}
			const url = `/download_chunk?public_id=${encodeURIComponent(public_id)}&file_id=${encodeURIComponent(file_id)}&chunk_id=${encodeURIComponent(chunk_id)}`;
			fetch(url)
				.then(resp => resp.ok ? resp.arrayBuffer() : Promise.reject('Failed to download chunk'))
				.then(buf => {
					state.chunks[chunk_id] = buf;
					state.received[chunk_id] = true;
					state.completed++;
					console.log(`Chunk ${chunk_id} downloaded and saved for fileKey ${fileKey}`);

					// Check if all chunks are received
					if (state.completed === state.totalChunks) {
						// All chunks received, assemble and download
						const blob = new Blob(state.chunks, {type: 'application/octet-stream'});
						const a = document.createElement('a');
						a.href = URL.createObjectURL(blob);
						a.download = state.fileName;
						a.click();
						if (state.downloadStartTime && state.btn) {
							const elapsed = ((Date.now() - state.downloadStartTime) / 1000).toFixed(2);
							state.btn.textContent = `Download (Done in ${elapsed}s)`;
						}
						delete downloadState[fileKey];
						console.log('File download complete:', state.fileName);
					} else {
						// Request the next chunk if not completed
						const next_chunk_id = state.next_Chunk_index++;
						if (next_chunk_id < state.totalChunks) {
							send_chunk_request(public_id, file_id, next_chunk_id);
						}
					}
				})
				.catch(err => {
					console.error('Chunk download failed:', err);
				});
		}

		function send_chunk_request(public_id, file_id, chunk_id) {
			ws.send(JSON.stringify({
				opcode: 12,
				data: {
					sender_public_id: my_public_id == -1 ? 1 : my_public_id,
					public_id: Number(public_id),
					file_id: file_id,
					chunk_id: chunk_id
				}
			}));
			// console.log("reqesut for id: " , chunk_id, " is sent");
		}


		function renderFiles() {
			const fileListDiv = document.getElementById('file-list');
			fileListDiv.innerHTML = '';
			Object.entries(filesByPublicId).forEach(([public_id, files]) => {
				if (Array.isArray(files) && files.length > 0) {
					const label = document.createElement('div');
					label.textContent = `Files from public_id ${public_id}:`;
					fileListDiv.appendChild(label);
					files.forEach(f => {
						const entry = document.createElement('div');
						entry.className = 'file-entry';
						entry.textContent = `${f.name} (${f.size} bytes, ${f.type || 'unknown'}) [id: ${f.id}]`;
						const btn = document.createElement('button');
						btn.textContent = 'Download';
						btn.onclick = function() {
							// Calculate total chunks for this file
							const totalChunks = Math.ceil(f.size / CHUNK_SIZE);
							const fileKey = public_id + ':' + f.id;
							// Allocate space for chunks and received flags
							downloadState[fileKey] = {
								chunks: Array(totalChunks).fill(null),
								received: Array(totalChunks).fill(false),
								totalChunks,
								fileName: f.name,
								fileSize: f.size,
								next_Chunk_index : MAX_PARALLEL_CHUNKS,
								completed: 0,
								downloadStartTime: Date.now(),
							    btn: btn
							};
							// Send MAX_PARALLEL_CHUNKS requests for this file
							for (let i = 0; i < Math.min(MAX_PARALLEL_CHUNKS, totalChunks); ++i) {
								send_chunk_request(public_id, f.id, i)
							}
						};
						entry.appendChild(btn);
						fileListDiv.appendChild(entry);
					});
				}
			});
		}
	</script>
</body>
</html>
