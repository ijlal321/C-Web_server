<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>File List WebSocket Client</title>
	<style>
		body { font-family: sans-serif; max-width: 600px; margin: auto; }
		#file-list { margin-top: 20px; }
		.file-entry { margin-bottom: 10px; }
		button { margin-left: 10px; }
	</style>
</head>
<body>
	<h2>File List (from WebSocket)</h2>
	<div id="file-list"></div>
	<div style="margin-top:30px;">
		<label style="color:blue; text-decoration:underline; cursor:pointer;">
			<input type="file" id="file-input" multiple style="display:none;">Add Files
		</label>
	</div>
	<script>
		// Handle file input for adding new files
		const fileInput = document.getElementById('file-input');
		let fileIdCounter = 1;
		fileInput.addEventListener('change', function(e) {
			if (!fileInput.files || fileInput.files.length === 0) return;
			const filesArr = Array.from(fileInput.files).map(f => ({
				id: fileIdCounter++,
				name: f.name,
				size: f.size,
				type: f.type || '',
				file: f, // keep original File object for possible upload
			}));
			// Send opcode 8 with new files to websocket
			if (ws && ws.readyState === WebSocket.OPEN) {
				ws.send(JSON.stringify({
					opcode: 8,
					data: {
						public_id: my_public_id == -1 ? 1 : my_public_id,
						file_count: filesArr.length,
						files: filesArr.map(({file, ...rest}) => rest)
					}
				}));
			}
			// Optionally, you can also add these files to filesByPublicId for immediate UI feedback
			if (my_public_id !== -1) {
				if (!Array.isArray(filesByPublicId[my_public_id])) filesByPublicId[my_public_id] = [];
				filesByPublicId[my_public_id].push(...filesArr);
				renderFiles();
			}
			fileInput.value = '';
		});
		// Generate random private_id
		function generateRandomId() {
			let arr = new Uint8Array(16);
			window.crypto.getRandomValues(arr);
			return Array.from(arr, b => b.toString(16).padStart(2, '0')).join('');
		}
		const private_id = generateRandomId();

		// Store files by public_id
		const filesByPublicId = {};

		const CHUNK_SIZE = 1024 * 1024 * 20;
		const MAX_PARALLEL_CHUNKS = 20;
		let my_public_id = -1;
		let bytes_loaded_this_sec = 0;

		const speedDiv = document.createElement('div');
		speedDiv.style.margin = '10px 0';
		speedDiv.style.fontWeight = 'bold';
		speedDiv.id = 'download-speed';
		document.body.insertBefore(speedDiv, document.getElementById('file-list'));

		// Infinite 1-second timer to show download speed
		setInterval(() => {
			// Calculate speed in bytes/sec, show as KB/s or MB/s
			let speed = bytes_loaded_this_sec;
			let speedStr;
			if (speed > 1024 * 1024) {
				speedStr = (speed / (1024 * 1024)).toFixed(2) + ' MB/s';
			} else if (speed > 1024) {
				speedStr = (speed / 1024).toFixed(2) + ' KB/s';
			} else {
				speedStr = speed + ' B/s';
			}
			speedDiv.textContent = `Download speed: ${speedStr}`;
			bytes_loaded_this_sec = 0;
		}, 1000);


		// Track download state for each file: fileKey -> {chunks, received, totalChunks, fileName, fileSize}
		const downloadState = {};

		// Map: fileKey -> {chunks: [], received: [], totalChunks, fileName, fileSize, completed}
		// Connect to WebSocket
		const ws = new WebSocket(`ws://${window.location.hostname}:8080/chat`);
		ws.onopen = function() {
			ws.send(JSON.stringify({ opcode: 0, data: { private_id } }));
		};

		ws.onmessage = function(event) {
			try {
				const msg = JSON.parse(event.data);
				if (msg.opcode === 10 && msg.data && typeof msg.data.public_id !== 'undefined' && Array.isArray(msg.data.files)) {
					filesByPublicId[msg.data.public_id] = msg.data.files;
					renderFiles();
				} else if (msg.opcode === 2) {
					// Accept public_id from server
					if (typeof msg.data === 'object' && 'public_id' in msg.data) {
						my_public_id = msg.data.public_id;
						console.log("id received : ", msg.data.public_id);
					}
				} else if (msg.opcode === 14 && msg.data && typeof msg.data.public_id !== 'undefined' && typeof msg.data.file_id !== 'undefined' && typeof msg.data.chunk_id !== 'undefined') {
					download_chunk(msg);
				} else if (msg.opcode === 13 && msg.data && typeof msg.data.public_id !== 'undefined' && typeof msg.data.file_id !== 'undefined' && typeof msg.data.chunk_id !== 'undefined') {
					uploadChunkFromUiFiles(msg.data.public_id, msg.data.file_id, msg.data.chunk_id);
				}
			} catch (e) {
				// Ignore non-JSON
			}
		}


		// Upload a chunk from the user's added files (for admin or file owner)
		function uploadChunkFromUiFiles(public_id, file_id, chunk_id) {
			// Find the file in filesByPublicId[my_public_id] if available
			const myFiles = filesByPublicId[my_public_id] || [];
			const file = myFiles.find(f => f.id === file_id && f.file);
			if (!file || !file.file) {
				// Optionally, try to find in a global uiFilesArr if you use one
				console.warn('File not found for upload', file_id);
				return;
			}
			const start = chunk_id * CHUNK_SIZE;
			const end = Math.min(start + CHUNK_SIZE, file.size);
			const blob = file.file.slice(start, end);
			// Upload via HTTP POST to /upload_chunk with query params and raw binary body
			const url = `http://${window.location.hostname}:8080/upload_chunk?public_id=${encodeURIComponent(public_id)}&file_id=${encodeURIComponent(file_id)}&chunk_id=${encodeURIComponent(chunk_id)}`;
			fetch(url, {
				method: 'POST',
				headers: {
					'Content-Type': 'application/octet-stream'
				},
				body: blob
			}).then(resp => {
				if (!resp.ok) throw new Error('Upload failed');
				// Optionally, show status
				// showStatus('Chunk uploaded', false);
			}).catch(err => {
				// Optionally, show status
				// showStatus('Chunk upload error: ' + err, true);
				console.error('Chunk upload error:', err);
			});
		}

			function download_chunk(msg) {
				const { public_id, file_id, chunk_id } = msg.data;
				const fileKey = public_id + ':' + file_id;
				const state = downloadState[fileKey];
				if (!state) {
					console.warn("No download state for fileKey", fileKey);
					return;
				}
				if (state.chunks[chunk_id] != null) {
					console.warn("Already Got File Chunk ?", fileKey, chunk_id);
					return;
				}

				const url = `/download_chunk?public_id=${encodeURIComponent(public_id)}&file_id=${encodeURIComponent(file_id)}&chunk_id=${encodeURIComponent(chunk_id)}`;

				const xhr = new XMLHttpRequest();
				xhr.open("GET", url, true);
				xhr.responseType = "arraybuffer";

				let lastLoaded = 0; // Track previous loaded value

				// Progress callback (fires repeatedly as data arrives)
				xhr.onprogress = function (event) {
					if (event.lengthComputable) {
						const delta = event.loaded - lastLoaded;
						bytes_loaded_this_sec += delta;
						lastLoaded = event.loaded;
					}
				};

				// Success
				xhr.onload = function () {
					if (xhr.status === 200) {
						const buf = xhr.response;
						state.chunks[chunk_id] = buf;
						state.received[chunk_id] = true;
						state.completed++;
						console.log(`Chunk ${chunk_id} downloaded and saved for fileKey ${fileKey}`);

						// Check if all chunks are received
						if (state.completed === state.totalChunks) {
							const blob = new Blob(state.chunks, { type: 'application/octet-stream' });
							const a = document.createElement('a');
							a.href = URL.createObjectURL(blob);
							a.download = state.fileName;
							a.click();

							if (state.downloadStartTime && state.btn) {
								const elapsed = ((Date.now() - state.downloadStartTime) / 1000).toFixed(2);
								state.btn.textContent = `Download (Done in ${elapsed}s)`;
							}
							delete downloadState[fileKey];
							console.log('File download complete:', state.fileName);
						} else {
							// Request the next chunk
							const next_chunk_id = state.next_Chunk_index++;
							if (next_chunk_id < state.totalChunks) {
								send_chunk_request(public_id, file_id, next_chunk_id);
							}
						}
					} else {
						console.error(`Failed to download chunk ${chunk_id}: HTTP ${xhr.status}`);
					}
				};

				// Error
				xhr.onerror = function () {
					console.error('Chunk download failed (network error)');
				};

				xhr.send();
			}

		function send_chunk_request(public_id, file_id, chunk_id) {
			ws.send(JSON.stringify({
				opcode: 12,
				data: {
					sender_public_id: my_public_id == -1 ? 1 : my_public_id,
					public_id: Number(public_id),
					file_id: file_id,
					chunk_id: chunk_id
				}
			}));
			// console.log("reqesut for id: " , chunk_id, " is sent");
		}


		function renderFiles() {
			const fileListDiv = document.getElementById('file-list');
			fileListDiv.innerHTML = '';
			Object.entries(filesByPublicId).forEach(([public_id, files]) => {
				if (Array.isArray(files) && files.length > 0) {
					const label = document.createElement('div');
					label.textContent = `Files from public_id ${public_id}:`;
					fileListDiv.appendChild(label);
					files.forEach((f, idx) => {
						const entry = document.createElement('div');
						entry.className = 'file-entry';
						entry.textContent = `${f.name} (${f.size} bytes, ${f.type || 'unknown'}) [id: ${f.id}]`;
						// If this is my file, show Remove, else show Download
						if (String(public_id) === String(my_public_id)) {
							const btn = document.createElement('button');
							btn.textContent = 'Remove';
							btn.onclick = function() {
								// Remove from UI
								files.splice(idx, 1);
								renderFiles();
								// Optionally, notify server of removal
								if (ws && ws.readyState === WebSocket.OPEN) {
									ws.send(JSON.stringify({
										opcode: 9,
										data: {
											public_id: my_public_id,
											file_id: f.id
										}
									}));
								}
							};
							entry.appendChild(btn);
						} else {
							const btn = document.createElement('button');
							btn.textContent = 'Download';
							btn.onclick = function() {
								// Calculate total chunks for this file
								const totalChunks = Math.ceil(f.size / CHUNK_SIZE);
								const fileKey = public_id + ':' + f.id;
								// Allocate space for chunks and received flags
								downloadState[fileKey] = {
									chunks: Array(totalChunks).fill(null),
									received: Array(totalChunks).fill(false),
									totalChunks,
									fileName: f.name,
									fileSize: f.size,
									next_Chunk_index : MAX_PARALLEL_CHUNKS,
									completed: 0,
									downloadStartTime: Date.now(),
									btn: btn
								};
								// Send MAX_PARALLEL_CHUNKS requests for this file
								for (let i = 0; i < Math.min(MAX_PARALLEL_CHUNKS, totalChunks); ++i) {
									send_chunk_request(public_id, f.id, i)
								}
							};
							entry.appendChild(btn);
						}
						fileListDiv.appendChild(entry);
					});
				}
			});
		}
	</script>
</body>
</html>
